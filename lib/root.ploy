// Â© 2015 George King. Permission to use this file is granted in ploy/license.txt.

in ROOT

nil = ()
Null =: ()

true  = host_val Bool "true";
false = host_val Bool "false";

void = fn ^T%Void;

not = host_val Bool%Bool "function($) { return !$; }";

extensible dec; // TODO: constraints.
dec += host_val Int%Int "function($) { return $ - 1; }";

extensible inc; // TODO: constraints.
inc += host_val Int%Int "function($) { return $ + 1; }";

extensible add; // TODO: constraints.
add += host_val (Int Int)%Int "function($) { return $._0 + $._1; }";

extensible sub; // TODO: constraints.
sub += host_val (Int Int)%Int "function($) { return $._0 - $._1; }";

extensible mul; // TODO: constraints.
mul += host_val (Int Int)%Int "function($) { return $._0 * $._1; }";

extensible div; // TODO: constraints.
div += host_val (Int Int)%Int "function($) { return $._0 / $._1; }";

extensible mod; // TODO: constraints.
mod += host_val (Int Int)%Int "function($) { return (($._0 % $._1) + $._1) % $._1; }";

extensible rem; // TODO: constraints.
rem += host_val (Int Int)%Int "function($) { return $._0 % $._1; }";


extensible eq; // TODO: constraints.
eq += fn (() ())%Bool true;
eq += host_val (Int Int)%Bool "function($) { return $._0 == $._1; }";
eq += host_val (Str Str)%Bool "function($) { return $._0 == $._1; }";

extensible ne; // TODO: constraints.
ne += fn (() ())%Bool false;
ne += host_val (Int Int)%Bool "function($) { return $._0 != $._1; }";

extensible ge; // TODO: constraints.
ge += fn (() ())%Bool true;
ge += host_val (Int Int)%Bool "function($) { return $._0 >= $._1; }";

extensible gt; // TODO: constraints.
gt += fn (() ())%Bool false;
gt += host_val (Int Int)%Bool "function($) { return $._0 >  $._1; }";

extensible le; // TODO: constraints.
le += fn (() ())%Bool true;
le += host_val (Int Int)%Bool "function($) { return $._0 <= $._1; }";

extensible lt; // TODO: constraints.
lt += fn (() ())%Bool false;
lt += host_val (Int Int)%Bool "function($) { return $._0 <  $._1; }";


exit = host_val Int%Never "function($) { HOST___process.exit($); }" HOST/_process;
std_out = host_val FS/File "$g.process.stdout.fd";
std_err = host_val FS/File "$g.process.stderr.fd";


extensible err; // TODO: make generic.
err += fn ()%Void FS/write(std_err "()");
err += fn Str%Void FS/write(std_err $);
err += fn Int%Void FS/write(std_err $);

extensible out; // TODO: make generic.
out += fn ()%Void FS/write(std_out "()");
out += fn Str%Void FS/write(std_out $);
out += fn Int%Void FS/write(std_out $);


extensible errL; // TODO: make generic.
errL += fn Int%Void err.$ err.'\n';
errL += fn Str%Void err.$ err.'\n';


extensible outL; // TODO: make generic.
outL += fn Int%Void out.$ out.'\n';
outL += fn Str%Void out.$ out.'\n';


fail = fn Str%Never
  errL.$
  exit.1;

abort = host_val Str%Never "function($) { throw new Error($); }";


assert = fn Bool%Void
  if not.$ ? abort.'assert failed.';;

;
