// Â© 2015 George King. Permission to use this file is granted in ploy/license.txt.

in ROOT

true  = host_val Bool "true";
false = host_val Bool "false";

not = host_val Bool%Bool "function($) { return !$; }";

extensible dec; // TODO: constraints.
dec += host_val Int%Int "function($) { return $ - 1; }";

extensible inc; // TODO: constraints.
inc += host_val Int%Int "function($) { return $ + 1; }";

extensible add; // TODO: constraints.
add += host_val (Int Int)%Int "function($) { return $._0 + $._1; }";

extensible sub; // TODO: constraints.
sub += host_val (Int Int)%Int "function($) { return $._0 - $._1; }";

extensible mul; // TODO: constraints.
mul += host_val (Int Int)%Int "function($) { return $._0 * $._1; }";

extensible div; // TODO: constraints.
div += host_val (Int Int)%Int "function($) { return $._0 / $._1; }";

extensible mod; // TODO: constraints.
mod += host_val (Int Int)%Int "function($) { return (($._0 % $._1) + $._1) % $._1; }";

extensible rem; // TODO: constraints.
rem += host_val (Int Int)%Int "function($) { return $._0 % $._1; }";


extensible eq; // TODO: constraints.
eq += host_val (Int Int)%Bool "function($) { return $._0 == $._1; }";
eq += host_val (Str Str)%Bool "function($) { return $._0 == $._1; }";

extensible ne; // TODO: constraints.
ne += host_val (Int Int)%Bool "function($) { return $._0 != $._1; }";

extensible ge; // TODO: constraints.
ge += host_val (Int Int)%Bool "function($) { return $._0 >= $._1; }";

extensible gt; // TODO: constraints.
gt += host_val (Int Int)%Bool "function($) { return $._0 >  $._1; }";

extensible le; // TODO: constraints.
le += host_val (Int Int)%Bool "function($) { return $._0 <= $._1; }";

extensible lt; // TODO: constraints.
lt += host_val (Int Int)%Bool "function($) { return $._0 <  $._1; }";


exit = host_val Int%Never "function($) { HOST___process.exit($); }" HOST/_process;
std_out = host_val FS/File "$g.process.stdout.fd";
std_err = host_val FS/File "$g.process.stderr.fd";


extensible err; // TODO: make generic.
err += fn Str%() FS/write(std_err $);
err += fn Int%() FS/write(std_err $);

extensible out; // TODO: make generic.
out += fn Str%() FS/write(std_out $);
out += fn Int%() FS/write(std_out $);


extensible errL; // TODO: make generic.

errL += fn Int%()
  err.$
  err.'\n';

errL += fn Str%()
  err.$
  err.'\n';


extensible outL; // TODO: make generic.

outL += fn Int%()
  out.$
  out.'\n';

outL += fn Str%()
  out.$
  out.'\n';


fail = fn Str%Never
  errL.$
  exit.1;

abort = host_val Str%Never "function($) { throw new Error($); }";


assert = fn Bool%()
  if not.$ ? abort.'assert failed.';;

;
