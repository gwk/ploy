# Â© 2015 George King. Permission to use this file is granted in ploy/license.txt.

in ROOT

true  = host_val Bool "true";
false = host_val Bool "false";

not = host_val Bool%Bool "function($) { return !$; }";

extensible dec; # TODO: constraints.
dec += host_val Int%Int "function($) { return $ - 1; }";

extensible inc; # TODO: constraints.
inc += host_val Int%Int "function($) { return $ + 1; }";

extensible add; # TODO: constraints.
add += host_val (Int Int)%Int "function($) { return $._0 + $._1; }";

extensible sub; # TODO: constraints.
sub += host_val (Int Int)%Int "function($) { return $._0 - $._1; }";

extensible mul; # TODO: constraints.
mul += host_val (Int Int)%Int "function($) { return $._0 * $._1; }";

extensible div; # TODO: constraints.
div += host_val (Int Int)%Int "function($) { return $._0 / $._1; }";

extensible mod; # TODO: constraints.
mod += host_val (Int Int)%Int "function($) { return (($._0 % $._1) + $._1) % $._1; }";

extensible rem; # TODO: constraints.
rem += host_val (Int Int)%Int "function($) { return $._0 % $._1; }";


extensible eq; # TODO: constraints.
eq += host_val (Int Int)%Bool "function($) { return $._0 == $._1; }";

extensible ne; # TODO: constraints.
ne += host_val (Int Int)%Bool "function($) { return $._0 != $._1; }";

extensible ge; # TODO: constraints.
ge += host_val (Int Int)%Bool "function($) { return $._0 >= $._1; }";

extensible gt; # TODO: constraints.
gt += host_val (Int Int)%Bool "function($) { return $._0 >  $._1; }";

extensible le; # TODO: constraints.
le += host_val (Int Int)%Bool "function($) { return $._0 <= $._1; }";

extensible lt; # TODO: constraints.
lt += host_val (Int Int)%Bool "function($) { return $._0 <  $._1; }";


exit = host_val Int%() "function($) { HOST___process.exit($); }" HOST/_process;
std_out = host_val FS/File "$g.process.stdout.fd";
std_err = host_val FS/File "$g.process.stderr.fd";


extensible err; # TODO: make generic.
err += fn Str%() FS/write(std_err $);
err += fn Int%() FS/write(std_err $);

extensible out; # TODO: make generic.
out += fn Str%() FS/write(std_out $);
out += fn Int%() FS/write(std_out $);


extensible errL; # TODO: make generic.

errL += fn Int%()
  err.$
  err.'\n';

errL += fn Str%()
  err.$
  err.'\n';


extensible outL; # TODO: make generic.

outL += fn Int%()
  out.$
  out.'\n';

outL += fn Str%()
  out.$
  out.'\n';


fail = fn Str%()
  errL.$
  exit.1;


assert = fn (Bool Str)%()
  # TODO: source location reporting using macros?
  if not.0@$ ? {
    err.'assert failed: '
    errL.1@$
    exit.1 };;

assert_eq = fn (Int Int Str)%()
  # TODO: make generic.
  if ne(0@$ 1@$) ? {
    err.'assert_eq failed: '
    err.0@$
    err.' != '
    err.1@$
    err.'; '
    err.2@$
    err.'\n'
    exit.1 };;

;
