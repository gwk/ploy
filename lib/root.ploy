# Â© 2015 George King. Permission to use this file is granted in ploy/license.txt.

in ROOT

true  = host_val Bool "true";
false = host_val Bool "false";

not = host_val Bool%Bool "function($) { return !$; }";

extensible dec; # TODO: constraints.
dec += host_val Int%Int "function($) { return $ - 1; }";

extensible inc; # TODO: constraints.
inc += host_val Int%Int "function($) { return $ + 1; }";

extensible add; # TODO: constraints.
add += host_val (Int Int)%Int "function($) { return $._0 + $._1; }";

extensible sub; # TODO: constraints.
sub += host_val (Int Int)%Int "function($) { return $._0 - $._1; }";

extensible mul; # TODO: constraints.
mul += host_val (Int Int)%Int "function($) { return $._0 * $._1; }";

extensible div; # TODO: constraints.
div += host_val (Int Int)%Int "function($) { return $._0 / $._1; }";

extensible mod; # TODO: constraints.
mod += host_val (Int Int)%Int "function($) { return (($._0 % $._1) + $._1) % $._1; }";

extensible rem; # TODO: constraints.
rem += host_val (Int Int)%Int "function($) { return $._0 % $._1; }";


extensible eq; # TODO: constraints.
eq += host_val (Int Int)%Bool "function($) { return $._0 == $._1; }";

extensible ne; # TODO: constraints.
ne += host_val (Int Int)%Bool "function($) { return $._0 != $._1; }";

extensible ge; # TODO: constraints.
ge += host_val (Int Int)%Bool "function($) { return $._0 >= $._1; }";

extensible gt; # TODO: constraints.
gt += host_val (Int Int)%Bool "function($) { return $._0 >  $._1; }";

extensible le; # TODO: constraints.
le += host_val (Int Int)%Bool "function($) { return $._0 <= $._1; }";

extensible lt; # TODO: constraints.
lt += host_val (Int Int)%Bool "function($) { return $._0 <  $._1; }";


exit = host_val Int%() "function($) { HOST___process.exit($); }" HOST/_process;
std_out = host_val FS/File "$g.process.stdout.fd";
std_err = host_val FS/File "$g.process.stderr.fd";


extensible err; # TODO: make generic.
err += fn Str%() FS/write_Str(std_err $);
err += fn Int%() FS/write_Int(std_err $);

err_Int: Int%() = err # TEMP.
err_Str: Str%() = err # TEMP.

extensible out; # TODO: make generic.
out += fn Str%() FS/write_Str(std_out $);
out += fn Int%() FS/write_Int(std_out $);

out_Int: Int%() = out # TEMP.
out_Str: Str%() = out # TEMP.

extensible errL; # TODO: make generic.

errL += fn Int%()
  err_Int.$
  err_Str.'\n';

errL += fn Str%()
  err_Str.$
  err_Str.'\n';


extensible outL; # TODO: make generic.

outL += fn Int%()
  out_Int.$
  out_Str.'\n';

outL += fn Str%()
  out_Str.$
  out_Str.'\n';

outL_Int: Int%() = outL # TEMP.


assert = fn (Bool Str)%()
  if not.0@$ ? {
    err.'assert failed: '
    errL(1@$)
    exit.1 };;

assert_eq = fn (Int Int Str)%()
  if ne(0@$ 1@$) ? {
    err_Str.'assert_eq failed: '
    err_Int.0@$
    err_Str.' != '
    err_Int.1@$
    err_Str.'; '
    err_Str.2@$
    err_Str('\n')
    exit.1 };;

;
