// Â© 2014-2017 Evan Wallace and contributors. Permission to use this file is granted under the terms of the MIT License.

// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// Ploy version by George King; derived from https://github.com/evanw/node-source-map-support/blob/master/source-map-support.js commit 3061a49.


'use strict';

let SourceMapConsumer = require('source-map').SourceMapConsumer;
let path = require('path');
let relPath = path.relative;
let fs = require('fs');
let origEmit = process.emit;
let errL = console.error;
let repr = JSON.stringify;

let reSourceMap = /^data:application\/json[^,]+base64,/; // detect source maps.

let fileContentsCache = {}; // path to file contents string.
let sourceMapCache = {}; // path to source map.


exports.install = function() {
  process.emit = emit;
  Error.prepareStackTrace = prepareStackTrace; // the V8 stack trace API.
  // see: https://github.com/v8/v8/wiki/Stack-Trace-API.
};


function emit(type) {
  if (type === 'uncaughtException') {
    let hasStack = (arguments[1] && arguments[1].stack);
    let hasListeners = (this.listeners(type).length > 0);
    if (hasStack && !hasListeners) {
      return printErrorAndExit(arguments[1]);
    }
  }
  return origEmit.apply(this, arguments);
}


function prepareStackTrace(error, siteStack) {
  // Lazily generate the value for error.stack.
  // We are also obliged to save the error description as a property here,
  // because afterwards the toString value changes to whatever we return!
  return siteStack.map(v8CallSiteToFrame);
}


function printErrorAndExit(error) {
  errL(`${BOLD}${TXT_R}uncaught exception:${RST} ${error.message}`)
  errL()
  let trimmedStack = trimStack(error.stack);
  let cwd = process.cwd();
  for (let line of trimmedStack) {
    errL(fmtFrame(line, cwd))
  }
  process.exit(1);
}


function v8CallSiteToFrame(site) {
  let isEval = site.isEval()
  return {
    // Most call sites return a value for getFileName(),
    // but code passed to eval() ending in '//# sourceURL=...' only has getScriptNameOrSourceURL().
    path: site.getFileName() || site.getScriptNameOrSourceURL(),
    line: site.getLineNumber() - 1, // v8 CallSite line is 1-indexed.
    col: site.getColumnNumber() -1, // v8 CallSite column is 1-indexed.
    name: site.getFunctionName(),
    isEval: isEval,
    isNative: site.isNative(),
    isTop: site.isToplevel(),
    evalOrigin: isEval ? site.getEvalOrigin() : null,
    //v8Desc: String(site),
  };
}


function fmtFrame(frame, cwd) {
  // perform source mapping.
  var {path, line, col, name} = frame;
  var pathRel = relPath(cwd, path);
  var foundSrc = false;
  if (path && !frame.isNative) {
    // mozilla source-map uses 1-indexed lines.
    let orig = mapSourcePosition({source: pathRel, line: line + 1, column: col});
    foundSrc = (pathRel != orig.source);
    var line1, srcName;
    ({source: path, line: line1, column: col, name: srcName} = orig);
    if (srcName !== undefined) {
      name = srcName;
    }
    line = line1 - 1;
  }
  // TODO: handling for method names?
  // TODO: additional handling for eval code? See original implementation for hints.
  var src = getSourceLine(path, line);
  if (src == null) { src = `${TXT_D}<MISSING>${RST}` }
  var dim = (foundSrc ? '' : TXT_L);
  return `${dim}${path}:${line + 1}:${col + 1}${name ? ': ' + name : ''}${RST}\n${TXT_D}| ${RST}${dim}${src}${RST}`;
}


let RST = '\x1b[0m'
let BOLD = '\x1b[1m'
let TXT_B = '\x1b[34m'
let TXT_C = '\x1b[36m'
let TXT_D = '\x1b[30m'
let TXT_G = '\x1b[32m'
let TXT_L = '\x1b[37m'
let TXT_M = '\x1b[35m'
let TXT_R = '\x1b[31m'
let TXT_Y = '\x1b[33m'


function getSourceLine(path, line_idx) {
  let contents = retrieveFile(path)
  if (!contents) { return null }
  let code = contents.split(/(?:\r\n|\r|\n)/)[line_idx];
  if (!code) { return null }
  return code
}


function trimStack(stack) {
  // Remove known, uninteresting frames from the bottom of the stack.
  let trimmed = Array.from(stack); // copy.
  let node_bottom = [
    ['module.js', 'Module._compile'],
    ['module.js', 'Module._extensions..js'],
    ['module.js', 'Module.load'],
    ['module.js', 'tryModuleLoad'],
    ['module.js', 'Module._load'],
    ['module.js', 'Module.runMain'],
    ['bootstrap_node.js', 'startup'],
  ].reverse();
  for (let [path, name] of node_bottom) {
    if (!trimmed.length) {
      errL('WARNING: node-source-map: trimStack reached bottom of stack.')
      return stack; // return original.
    }
    let last = trimmed[trimmed.length - 1];
    if (last.path == path && last.name == name) {
      trimmed.pop();
    } else {
      //break; note: used to break out, but node's stack bottom appears to have vary!
    }
  }
  return trimmed;
}


function mapSourcePosition(position) {
  var sourceMap = sourceMapCache[position.source];
  if (!sourceMap) {
    var urlAndMap = retrieveSourceMap(position.source);
    if (urlAndMap) {
      sourceMap = sourceMapCache[position.source] = {
        url: urlAndMap.url,
        map: new SourceMapConsumer(urlAndMap.map)
      };

      // Load all sources stored inline with the source map into the file cache
      // to pretend like they are already loaded. They may not exist on disk.
      if (sourceMap.map.sourcesContent) {
        sourceMap.map.sources.forEach(function(source, i) {
          var contents = sourceMap.map.sourcesContent[i];
          if (contents) {
            let buffer = Buffer.from(contents.data);
            let string = buffer.toString('utf8')
            fileContentsCache[source] = string; // TODO: split into lines once here.
          }
        });
      }
    } else {
      sourceMap = sourceMapCache[position.source] = {
        url: null,
        map: null
      };
    }
  }

  // Resolve the source URL relative to the URL of the source map.
  if (sourceMap && sourceMap.map) {
    var originalPosition = sourceMap.map.originalPositionFor(position);

    // Only return the original position if a matching line was found.
    // If no matching line is found then we return position instead,
    // which will cause the stack trace to print the path and line for the compiled file.
    // It is better to give a precise location in the compiled file than a vague location in the original file.
    if (originalPosition.source !== null) {
      return originalPosition;
    }
  }

  return position;
}


function isInBrowser() {
  return ((typeof window !== 'undefined')
    && (typeof XMLHttpRequest === 'function')
    && !(window.require && window.module && window.process && window.process.type === 'renderer'));
}


function retrieveFile(path) {
  if (path in fileContentsCache) {
    return fileContentsCache[path];
  }
  var contents = null;
  if (!fs) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', path, false);
    xhr.send(null);
    if (xhr.readyState === 4 && xhr.status === 200) {
      contents = xhr.responseText;
    }
  } else if (fs.existsSync(path)) {
    contents = fs.readFileSync(path, 'utf8');
  }
  return fileContentsCache[path] = contents;
}


function retrieveSourceMapURL(source) {
  var fileData;

  if (isInBrowser()) {
    try {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', source, false);
      xhr.send(null);
      fileData = xhr.readyState === 4 ? xhr.responseText : null;
      var sourceMapHeader = xhr.getResponseHeader('SourceMap') || xhr.getResponseHeader('X-SourceMap');
      if (sourceMapHeader) {
        return sourceMapHeader;
      }
     } catch (e) {}
  }

  // Get the URL of the source map.
  fileData = retrieveFile(source);
  var re = /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/)[ \t]*$)/mg;
  // find the last sourceMappingURL to avoid comments, strings, etc.
  var lastMatch, match;
  while (match = re.exec(fileData)) lastMatch = match;
  if (!lastMatch) return null;
  return lastMatch[1];
};


// Takes a generated source filename; returns a {map, optional url} object, or null if there is no source map.
// The map field may be either a string or the parsed JSON object, as required by SourceMapConsumer constructor.
function retrieveSourceMap(source) {
  var sourceMappingURL = retrieveSourceMapURL(source);
  if (!sourceMappingURL) return null;

  // Read the contents of the source map.
  var sourceMapData;
  if (reSourceMap.test(sourceMappingURL)) {
    // Support source map URL as a data url.
    var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);
    sourceMapData = new Buffer(rawData, 'base64').toString();
    sourceMappingURL = source;
  } else {
    // Support source map URLs relative to the source URL.
    sourceMappingURL = supportRelativeURL(source, sourceMappingURL); // necessary.
    sourceMapData = retrieveFile(sourceMappingURL);
  }

  if (!sourceMapData) {
    return null;
  }
  return {
    url: sourceMappingURL,
    map: sourceMapData
  };
}


function supportRelativeURL(file, url) {
  // Support URLs relative to a directory, but be careful about a protocol prefix
  // in case we are in the browser (i.e. directories may start with 'http://').
  if (!file) return url;
  var dir = path.dirname(file);
  var match = /^\w+:\/\/[^\/]*/.exec(dir);
  var protocol = match ? match[0] : '';
  return protocol + path.resolve(dir.slice(protocol.length), url);
}
